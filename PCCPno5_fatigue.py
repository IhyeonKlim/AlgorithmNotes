#재귀함수 : 자기 자신을 호출하는 프로세스를 가지고 있는 함수.

#문제. 3을 입력받으면 1부터 3까지 재귀를 이용해 출력하는 함수.

#ex) 깊이 우선 탐색 = DFS(Depth First Search)
#cf) 너비 우선 탐색 = BFS(Breadth First Search)
def DFS(n):
    if n > 0 :   
        #print(n, end=' ') 3,2,1로 출력
        DFS(n-1)
        print(n, end=' ')
        #print함수가 재귀 밑으로 바뀌는 순간 1,2,3으로 출력
DFS(3)

# *함수는 호출되면 stack에 쌓인다. 스택은 상단 프레임부터 실행된다.
*** 
    스택에는 DFS(3)이 제일 아래 쌓여있고, 3라인(DFS(2))에서 멈추고 sleep 상태가 되어있다.
    그 위에 DFS(2)가 올라가고, 3라인(DFS(1))에서 멈추고 sleep.
    그 위에 DFS(1)이 동일하게. 그 위에 DFS(0)가 올라가있다. 
    이제 자기 할일이 끝나면 stack에서 pop 된다. 사라진 DFS(0)이 사라지고나면
    DFS(1)의 3라인으로 돌아와서 4라인인 print(1)을 출력한다.
    DFS(2),DFS(3)도 마찬가지. 그래서 1,2,3이 찍히는 것이다.    
***

#중복 순열 문제.

***
    매개변수 n,k에 자연수가 입력되면 1부터 n까지의 수 중에서 중복을 허락하여 
        k개를 뽑아 일렬로 나열하는 방법의 수를 출력하는 프로그램을 작성하세요.
    만약 n=3, k=2이면 화면에 11,12,13,21,22,23,31,32,33을 출력한다.
    
***
    #L = level, n = n, k = k, p = []
    def DFS(L, n, k, p):
        if L == k:
            for x in p:
                print(x, end='')
            print()
        else:
            #1부터 n까지 도는거다.
            for i in range(1, n+1):
                p.append(i)
                DFS(L+1,n,k,p) #line 9
                p.pop()
    def solution(n,k):
        DFS(0,n,k,[])
        return end
    print(solution(3,2))

*** 다음은 DFS(L)이다.
        
                        DFS(0)
                    1      2      3        #i값이 1부터 n까지 움직인다. p라는 배열에 1이 들어가있다.
                  DFS(1) DFS(1)  DFS(1)    # 여기서 승택은 DFS(0) -9line 그 위에 DFS(1)이 있다.
            1      2      3                #다시 i값이 1부터 n까지 움직인다. p라는 배열에 1을 추가한다. 그러면 p에는 1,1이 들어있다.
        DFS(2)  DFS(2)  DFS(2)             # DFS(1) -9line에서 다시 멈추고 DFS(2)가 작동한다. 
    1      2      3                        # 여기서 L이 2다. L과 k가 같으므로 print로 1 1을 찍는다.
                                           # 그러면 여기서 끝났다. DFS(2) pop 되고 끝난다. 다시 DFS(1)-9line으로 간다. 
                                           # p에는 1 1이 있다. p.pop() 시키면 1이 빠지고 1만 남는다. 그리고 다시 i값이 2가되면 p에 2를 추가한다.   
                                            # 그러면 다시 DFS(1) -9line에서 멈추고 i=2, DFS(2)를 이제 출력한다. p(1,2)를 출력해서 다시 돈다. 이것의 반복.
                                            # 따라서 i = 3, DFS(2)까지 끝내면 13까지 찍는다. 스택에서 i=1 DFS(1)이 pop되고 DFS(0)-9line으로 와서 대기.
                                            # 그리고 다시 i = 2, DFS(1)로 간다.                         
                        
***
